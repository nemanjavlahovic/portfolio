<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
    <link rel="icon" href="../assets/images/1311.png" />
		<title>Modern Core Data with SwiftUI - Nemanja's iOS Portfolio</title>
    <meta name="description" content="Explore the latest Core Data features and integration patterns with SwiftUI, including @FetchRequest and CloudKit synchronization.">
    <meta name="viewport" content="width=device-width, initial-scale=1" />

		<link rel="stylesheet" href="../css/layout.css">
    <link rel="stylesheet" href="../css/typography.css">
    <link rel="stylesheet" href="../css/utilities.css">

		<script defer src="../js/script.js"></script>
	</head>
	<body>
    <!-- NAVBAR -->
    <div class="navbar">
      <a class="nav-title-link" href="../index.html">
        <span class="nav-title">Nemanja's iOS Portfolio</span>
      </a>
      <div style="display: flex; gap: 16px; align-items: center;">
        <a class="button" href="../blog.html">
          <span class="button-text">Blog</span>
        </a>
        <a class="button" href="mailto:nemanja@nemanjavlahovic.com">
          <span class="button-text">Contact Me</span>
        </a>
      </div>
    </div>

    <!-- MAIN PAGE CONTENT -->
    <div id="main-content">

      <!-- BLOG POST HEADER -->
      <div id="project-header">
        <div class="main-title">Modern Core Data with SwiftUI</div>
        <div class="body-text">Explore the latest Core Data features and how to integrate them seamlessly with SwiftUI. Learn about @FetchRequest, NSPersistentCloudKitContainer, and data synchronization patterns.</div>
        <div class="image-caption">Published on November 30, 2024 • 12 min read</div>
      </div>

      <!-- BLOG POST CONTENT -->
      <div id="project-details">
        <div class="subheader-text">Introduction</div>
        <div class="project-details-content">
          <div class="body-text">Core Data has evolved significantly with SwiftUI, offering more reactive and declarative patterns for data management. The introduction of @FetchRequest, CloudKit integration, and improved concurrency support has made Core Data more powerful and easier to use in modern iOS applications.</div>
          
          <div class="body-text">In this comprehensive guide, I'll walk you through implementing modern Core Data patterns with SwiftUI, covering everything from basic setup to advanced CloudKit synchronization. These techniques have been battle-tested in production applications handling thousands of records.</div>
        </div>
      </div>

      <div id="project-details">
        <div class="subheader-text">Setting Up Core Data with SwiftUI</div>
        <div class="project-details-content">
          <div class="body-text">Modern Core Data setup emphasizes dependency injection and testability. Here's how to structure your Core Data stack for SwiftUI applications:</div>
          
          <div class="body-text code-block">
class PersistenceController: ObservableObject {<br>
&nbsp;&nbsp;&nbsp;&nbsp;static let shared = PersistenceController()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;lazy var container: NSPersistentContainer = {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let container = NSPersistentContainer(name: "DataModel")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Configure for CloudKit if needed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guard let description = container.persistentStoreDescriptions.first else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fatalError("Failed to retrieve a persistent store description.")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;container.loadPersistentStores { _, error in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if let error = error {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fatalError("Core Data failed to load: \(error.localizedDescription)")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;container.viewContext.automaticallyMergesChangesFromParent = true<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return container<br>
&nbsp;&nbsp;&nbsp;&nbsp;}()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;var viewContext: NSManagedObjectContext {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;container.viewContext<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}
          </div>
          
          <div class="body-text">Inject the managed object context into your SwiftUI environment:</div>
          
          <div class="body-text code-block">
@main<br>
struct MyApp: App {<br>
&nbsp;&nbsp;&nbsp;&nbsp;let persistenceController = PersistenceController.shared<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;var body: some Scene {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WindowGroup {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContentView()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.environment(\.managedObjectContext, persistenceController.viewContext)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}
          </div>
        </div>
      </div>

      <div id="project-details">
        <div class="subheader-text">Mastering @FetchRequest</div>
        <div class="project-details-content">
          <div class="body-text">@FetchRequest is the cornerstone of reactive Core Data in SwiftUI. It automatically updates your UI when the underlying data changes, creating truly reactive applications.</div>
          
          <div class="body-text"><strong>Basic FetchRequest Usage:</strong></div>
          
          <div class="body-text code-block">
struct TaskListView: View {<br>
&nbsp;&nbsp;&nbsp;&nbsp;@FetchRequest(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sortDescriptors: [NSSortDescriptor(keyPath: \Task.createdDate, ascending: false)],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predicate: NSPredicate(format: "isCompleted == %@", NSNumber(value: false))<br>
&nbsp;&nbsp;&nbsp;&nbsp;) var incompleteTasks: FetchedResults&lt;Task&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;var body: some View {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List(incompleteTasks) { task in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TaskRowView(task: task)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}
          </div>
          
          <div class="body-text"><strong>Dynamic FetchRequest:</strong> For more complex scenarios, you can dynamically modify fetch requests:</div>
          
          <div class="body-text code-block">
struct FilterableTaskListView: View {<br>
&nbsp;&nbsp;&nbsp;&nbsp;@State private var showCompleted = false<br>
&nbsp;&nbsp;&nbsp;&nbsp;@State private var searchText = ""<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;var body: some View {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TaskListView(showCompleted: showCompleted, searchText: searchText)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.searchable(text: $searchText)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.toolbar {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Toggle("Show Completed", isOn: $showCompleted)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
<br>
struct TaskListView: View {<br>
&nbsp;&nbsp;&nbsp;&nbsp;let showCompleted: Bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;let searchText: String<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;var body: some View {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DynamicTaskList(predicate: buildPredicate())<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;private func buildPredicate() -> NSPredicate {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var predicates: [NSPredicate] = []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !showCompleted {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predicates.append(NSPredicate(format: "isCompleted == NO"))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !searchText.isEmpty {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;predicates.append(NSPredicate(format: "title CONTAINS[cd] %@", searchText))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return NSCompoundPredicate(andPredicateWithSubpredicates: predicates)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}
          </div>
        </div>
      </div>

      <div id="project-details">
        <div class="subheader-text">CloudKit Integration</div>
        <div class="project-details-content">
          <div class="body-text">NSPersistentCloudKitContainer provides seamless synchronization between Core Data and CloudKit, enabling data sync across user devices with minimal additional code.</div>
          
          <div class="body-text"><strong>Setting Up CloudKit:</strong></div>
          
          <div class="body-text code-block">
class CloudKitPersistenceController: ObservableObject {<br>
&nbsp;&nbsp;&nbsp;&nbsp;lazy var container: NSPersistentCloudKitContainer = {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let container = NSPersistentCloudKitContainer(name: "DataModel")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guard let description = container.persistentStoreDescriptions.first else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fatalError("Failed to retrieve a persistent store description.")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Configure CloudKit<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description.setOption(true as NSNumber, forKey: NSPersistentCloudKitContainerOptionsKey)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;container.loadPersistentStores { _, error in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if let error = error {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("CloudKit failed to load: \(error.localizedDescription)")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;container.viewContext.automaticallyMergesChangesFromParent = true<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return container<br>
&nbsp;&nbsp;&nbsp;&nbsp;}()<br>
}
          </div>
          
          <div class="body-text"><strong>Handling CloudKit Sync States:</strong> Provide user feedback for sync operations:</div>
          
          <div class="body-text code-block">
@MainActor<br>
class CloudKitSyncMonitor: ObservableObject {<br>
&nbsp;&nbsp;&nbsp;&nbsp;@Published var syncStatus: SyncStatus = .idle<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;enum SyncStatus {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case idle, syncing, error(String)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;init(container: NSPersistentCloudKitContainer) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NotificationCenter.default.addObserver(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forName: .NSPersistentCloudKitContainerEventChangedNotification,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object: container,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue: .main<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;) { [weak self] notification in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self?.handleCloudKitEvent(notification)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;private func handleCloudKitEvent(_ notification: Notification) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;guard let event = notification.userInfo?[NSPersistentCloudKitContainerEventChangedNotificationUserInfoKey] as? NSPersistentCloudKitContainer.Event else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch event.type {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case .setup, .import, .export:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.startDate != nil && event.endDate == nil {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncStatus = .syncing<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if event.endDate != nil {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;syncStatus = event.error != nil ? .error(event.error!.localizedDescription) : .idle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@unknown default:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}
          </div>
        </div>
      </div>

      <div id="project-details">
        <div class="subheader-text">Advanced Data Operations</div>
        <div class="project-details-content">
          <div class="body-text">For complex data operations, use background contexts to avoid blocking the UI thread. This is especially important for bulk operations and data imports.</div>
          
          <div class="body-text"><strong>Background Context Operations:</strong></div>
          
          <div class="body-text code-block">
extension PersistenceController {<br>
&nbsp;&nbsp;&nbsp;&nbsp;func performBackgroundTask&lt;T&gt;(_ block: @escaping (NSManagedObjectContext) throws -> T) async throws -> T {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return try await withCheckedThrowingContinuation { continuation in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let context = container.newBackgroundContext()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context.perform {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = try block(context)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try context.save()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continuation.resume(returning: result)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continuation.resume(throwing: error)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;func bulkImportTasks(from data: [TaskData]) async throws {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try await performBackgroundTask { context in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for taskData in data {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let task = Task(context: context)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;task.title = taskData.title<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;task.createdDate = Date()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;task.isCompleted = false<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}
          </div>
          
          <div class="body-text"><strong>Batch Operations:</strong> For operations affecting many objects, use batch requests for better performance:</div>
          
          <div class="body-text code-block">
func markAllTasksAsCompleted() async throws {<br>
&nbsp;&nbsp;&nbsp;&nbsp;try await performBackgroundTask { context in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let batchUpdateRequest = NSBatchUpdateRequest(entityName: "Task")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;batchUpdateRequest.propertiesToUpdate = ["isCompleted": true]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;batchUpdateRequest.predicate = NSPredicate(format: "isCompleted == NO")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;batchUpdateRequest.resultType = .updatedObjectIDsResultType<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = try context.execute(batchUpdateRequest) as? NSBatchUpdateResult<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let objectIDs = result?.result as? [NSManagedObjectID] ?? []<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Merge changes into view context<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let changes = [NSUpdatedObjectsKey: objectIDs]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [viewContext])<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}
          </div>
        </div>
      </div>

      <div id="project-details">
        <div class="subheader-text">Testing Core Data with SwiftUI</div>
        <div class="project-details-content">
          <div class="body-text">Testing Core Data requires careful setup of in-memory stores and proper context management. Here's how to create testable Core Data code:</div>
          
          <div class="body-text code-block">
extension PersistenceController {<br>
&nbsp;&nbsp;&nbsp;&nbsp;static var preview: PersistenceController = {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let controller = PersistenceController(inMemory: true)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let context = controller.container.viewContext<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add sample data for previews<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let sampleTask = Task(context: context)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sampleTask.title = "Sample Task"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sampleTask.createdDate = Date()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sampleTask.isCompleted = false<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try? context.save()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return controller<br>
&nbsp;&nbsp;&nbsp;&nbsp;}()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;init(inMemory: Bool = false) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;container = NSPersistentContainer(name: "DataModel")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if inMemory {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;container.persistentStoreDescriptions.first?.url = URL(fileURLWithPath: "/dev/null")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;container.loadPersistentStores { _, error in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if let error = error {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fatalError("Core Data failed to load: \(error.localizedDescription)")<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;container.viewContext.automaticallyMergesChangesFromParent = true<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}
          </div>
        </div>
      </div>

      <div id="project-details">
        <div class="subheader-text">Conclusion</div>
        <div class="project-details-content">
          <div class="body-text">Modern Core Data with SwiftUI offers powerful tools for building reactive, data-driven applications. The combination of @FetchRequest for reactive UI updates, CloudKit integration for seamless synchronization, and proper background context usage creates a robust foundation for any iOS application.</div>
          
          <div class="body-text">Key takeaways for successful Core Data implementation include: proper dependency injection through environment values, leveraging @FetchRequest for reactive UI updates, implementing background contexts for heavy operations, and testing with in-memory stores for reliable unit tests.</div>
          
          <div class="body-text">As you implement these patterns in your own applications, remember to start simple and add complexity gradually. Monitor performance, especially with CloudKit synchronization, and always test your data layer thoroughly to ensure a smooth user experience.</div>
        </div>
      </div>

      <!-- NAVIGATION -->
      <div style="display: flex; gap: 16px; margin-top: 48px;">
        <a class="button" href="../blog.html">
          <span class="button-text">← Back to Blog</span>
        </a>
        <a class="button" href="../index.html">
          <span class="button-text">Portfolio</span>
        </a>
      </div>
    </div>

    <!-- FOOTER -->
    <div id="footer">
      <a class="icon-link" target="_blank" href="https://www.linkedin.com/in/nemanja-vlahovic/">
        <img src="../assets/icons/linkedin.svg" class="footer-icon" alt="LinkedIn icon"/>
      </a>
      <a class="icon-link" href="mailto:nemanja@nemanjavlahovic.com">
        <img src="../assets/icons/mail.svg" class="footer-icon" alt="Email icon"/>
      </a>
    </div>

	</body>
</html>